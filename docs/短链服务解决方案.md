## 业务问题思考

### 问题一：长链的关系和短链的关系是一对一还是一对多？

* 一个长链，在不同情况下，生成的短网址应该不一样，才不会造成冲突

* 多渠道推广下，也可以区分统计不同渠道的效果质量
    * 这个场景就是我们根据短网址去区分渠道，但是长链是一样的。这样的话可以看到业务渠道的质量。
* 所以是 一个短链接只能对应一个长链接，当然一个长链接可以对应多个短链接



### 问题二：前端访问短链是如何跳转到对应的页面的？

* 服务端转发

    * 由服务器端进行的页面跳转，刚学Servlet时， 从OneServlet中转发到TwoServlet
    * 地址栏不发生变化，显示的是上一个页面的地址
    * 请求次数：只有1次请求
    * 转发只能在同一个应用的组件之间进行，不可以转发给其他应用的地址

* 页面的跳转-重定向

    * 由浏览器端进行的页面跳转

    * 重定向涉及到3xx状态码，访问跳转是301还是302，301和302代表啥意思？
        * 301 是永久重定向
            * 会被浏览器硬缓存，第一次会经过短链服务，后续再访问直接从浏览器缓存中获取目标地址
        * 302 是临时重定向
            * 不会被浏览器硬缓存，每次都是会访问短链服务
        * 短地址一经生成就不会变化，所以用 301 是同时对服务器压力也会有一定减少
        * 但是如果使用了 301，无法统计到短地址被点击的次数
        * 所以选择302虽然会增加服务器压力，但是有很多数据可以获取进行分析
        * 选择使用302，这个也可以对违规推广的链接进行实时封禁



### 问题三：短链码如何是如何生成的

* 短链码特点
    * 生成性能强劲: 高并发场景下能保证性能
    * 碰撞概率低
        * 避免重复：短链码比较短，只有六到八位
        * 恶意猜测：不能通过短链来猜测到我们有多少短链；不能让别人恶意爬取（比如说我们服务的商家）
    * 业务规则安全



### 短链生成方式

* 自增ID

    * 利用插入数据库，利用数据库自增id
    * 把自增id转成62进制作为短链码
    * 短链码的长度不固定，随着 id 变大，短链码长度也增长
    * 可以指定从某个长度开始增长，到百亿、千亿数量
    * 转换工具：https://tool.lu/hexconvert/
    * 是否存在重复: 不重复
    * 但短链码是有序的递增，存在【业务数据安全】问题

* MD5内容压缩

    * 长链接做md5加密

  ```
  43E08496,9E5CF455,E6D2D2B3,3407A6D2
  ```

    * 加密串查询是否已经生成过短链接
        * 如果已经存在，则拼接时间戳再MD5加密，插入数据库
        * 如果不存在则把长链接、长链接加密串插入数据库
    * 取MD5后 最后1 个 8 位字符串作为短链码
    * 是否存在重复: 存在碰撞（重复）可能
    * 是有损压缩算法，数据量超大情况碰撞概率越大

* 哈希算法：将一个元素映射成另一个元素

    * 加密哈希，如SHA256、MD5

    * 非加密哈希，如MurMurHash，CRC32



* MurMurHash（最后用的）

  ```
  Murmur哈希是一种非加密散列函数，适用于一般的基于散列的查找。
  它在2008年由Austin Appleby创建，在Github上托管，名为“SMHasher” 的测试套件。 
  它也存在许多变种，所有这些变种都已经被公开。 
  该名称来自两个基本操作，乘法（MU）和旋转（R）--来自百科
  ```

    * 是一种【非加密型】哈希函数且【随机分布】特征表现更良好

    * 由于是非加密的哈希函数，性能会比MD5强

    * 很多地方都用到比如Guava、Jedis、HBase、Lucence等

    * 存在两个版本

        * MurmurHash2（产生32位或64位值）
        * MurmurHash3（产生32位或128位值）

    * 数据量

        * MurmurHash的 32 bit 能表示的最大值近 43 亿的10进制
            * 满足多数业务,如果接近43亿则冲突概率大

        * 产品目标【超理想情况】

      ```
      首年日活用户： 10万
      首年日新增短链数据：10万*50 = 500万
      年新增短链数：500万 * 365天 = 18.2亿 
      年新增用户数：50万/1年
      年营收目标: 10万付费用户 * 客单价200元 = 2千万
      新增短链：50条/用户每日
      ```

        * MurMurHash得到的数值是10进制，一般会转化为62进制进行缩短
            * 例子
                * 10进制：1813342104
                * 转62进制：1YIB7i
                * https://tool.lu/hexconvert/

        * 常规短链码是6~8位数字+大小写字母组合

      ```
      0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
      6 位 62 进制数可表示 568 亿个短链（62的6次方，每位都有62个可能，如果扩大位数到7位，则可以支持3万5200亿）
      ```

        * MurmurHash的 32 bit 满足多数业务 43亿
            * 拼接上库-表位则可以表示更多数据（后续会讲分库分表的，库表位）
            * 7位则可以到到 43亿 * 62 = 2666亿
            * 8位则可以到到 2666亿 * 62 = 1.65万亿条数据
            * 结合短链过期数据归档，理论上满足未来全部需求了
        * 数据库存储
            * 单表1千万 * 62个库 * 62表 = 384亿数据



## 敏感数据和ID暴露风险

什么是数据脱敏？

* 也叫数据的去隐私化，在给定脱敏规则和策略的情况下，对敏感数据比如 `手机号`、`身份证` 等信息，进行转换或者修改的一种技术手段，防止敏感数据直接在不可靠的环境下使用和泄露、撞库等
* 技术分两类

    * 静态数据脱敏
        * 将生产数据导出，进行对外发送或者给开发、测试人员等
    * 动态数据脱敏
        * 程序直接连接生产数据的场景，如运维人员在运维的工作中直接连接生产数据库进行运维
        * 客服人员在生产中通过后台查询的个人信息



**数据库业务规则安全：自增ID暴露的商业秘密**

* 背景

  ```
  作为后端开发人员肯定离不开数据库设计，尽管你知道数据安全、接口安全、网络安全，但你也很大可能不小心暴露的公司的核心机密。 
  【做空上市公司的股票】如果你有炒股，那你知道如果这个数据库设计漏洞被他人知道，就可以做空一个上司公司的股票的不？
  【摧毁对手的利器】如果一个公司在是靠业务数据来说话的，如果被他人知道，在核心的时间点，被披露出来，那融资可能凉凉，企业可能面临倒闭。
  ```

* 在某天一个竞争对手 老王 做竞品调研的时候，注册了你公司的应用

  ```
  【暴露了总用户量】
  通过业务接口抓包分析(假定数据没做加密或者加密被破解了)，被他发现了自增id这个事情，他好几个号注册了，编号都是一百多万，每次id都是自增1, 用户量最多100多万，就此暴雷了。
  经过有经验的人知道不能对外暴露id这个事情，但是总有关联的业务，或者其他不知道的人员开发了对应的功能，比如 订单表、记录表、收藏表或者其他和user_id有关联的，只要他操作业务，接口有返回user_id，就容易出问题了。
  ```

  ```
  【暴露了每日拉新数据】
  如果是用户自增id，老王 肯定不单停留这里这么简单，假如他想看这个产品每日新增的用户有多少。
  毕竟拉新这个指标是很多公司都离不开的，比如通过投放广告、买量业务等等去获取新用户。
  老王想看下这个公司每天新增用户量大不大，他就今天注册一个看id多少，明天再注册一个看id多少；
  通过一段时间内去统计每天递增的值，老王就可以推断出平台新增用户大概是多少了，公司的拉新能力如何。
  ```

  ```
  【暴露了平台商品数量-订单数量】
  同样的思路，去爬取电商平台的商品，爬取平台最大的商品id, 第二天再次爬取，持续一段时间。就可以可以推断出新品发布数量。同样的思路，去抓取订单接口，看最大id是多少, 第二天再次爬取，持续一段时间。就可以推断出这个公司的每天订单量有多大。
  ```

**正常的的业务表会用自增id，但是也会加一个业务id。增加了 biz_id，这个就是业务id, 如果有关联，则用 biz_id进行关联并返回，这个可以是varchar类型，long雪花算法。其实最靠谱的就是，不要把有业务规则的id暴露给用户，不止id字段，类似的敏感字段都是。**