### 现状

我们的分库分表是按照用户创建的短链来的，用户创建短链可以路由到不同的库表上面，但是商家怎么办呢？商家创建的短链是没有规律的，分布在不同的库表之上。这个时候如果商家要查看自己所有的短链，此时就会触发全库表路由（非常消耗性能）



### 原因

- 不同维度看数据，场景是不一样的
    - 主要是分有PartitionKey和没有PartitionKey两种场景
        - 比如订单表的partitionkey是user_id，这个时候只需要根据user_id去进行hash取模，就可以路由到对应的库表上，所以用户查看自己的订单是非常方便的
        - 但是商家的订单就是分布在不同的节点上。查看非常不方便。



### 解决方案

- 字段解析配置
    - 建一个表，存储account_no（商家的账号进行hash）对应的库表位，商家生成的短链码固定前缀或者后缀（这个表里存放的字段有商家的account_no hash、库位、表位）
    - 就是让短链码当中包含商家的信息
    - 这样就相当于是每个商家的短链信息有固定的形式，放在固定的库表内
    - 商家查看的过程：
        - 首先根据account_no（商家的账号进行hash）去库表查询对应的库表编号，生成短链码固定库表位
        - 查询短链列表，去库表查询对应的库表编号，然后查询对应的库表
        - 这个时候会触发多次sql，但是不会造成全库表路由



- NOSQL冗余
    - 让订单冗余在nosql上面一份
    - 用户访问：
        - 根据不同的user_id进行取模进入不同的库，然后进入到canal-server（伪装成一个mysql的从节点进行通讯，监听库的变化）
        - 监听到了之后发给kafka（削峰）
        - kafka再写给ElasticSearch（这个还可以做一个日志的归档）
    - 店铺商家：
        - 直接去ElasticSearch去查询



- 本身库表冗余双写方案

  我们不管按照卖家的id进行订单切分还是按照买家的id进行订单切分，都不能满足双方同时查询的需求，所以我们在下单的时候同时写两个库，一个买家库一个卖家库（分别按照不同的id进行切分）

    - 部分字段冗余
    - 全部字段冗余

- 冗余双写带来的问题

    - 存储空间更多（空间换时间）
    - 如何实现
    - 分布式事务的问题（因为冗余双写需要同时操作不同的库）
        - 商家创建表的时候，首先是需要记录在普通用户表中，然后再记录在商家表中，这两个表通常在不同的库中。不能出现一个成功一个没有成功的情况。

- 实现方案一：

    - 直接RPC调用+Seata分布式事务框架（@GlobalTransaction）
    - 优点：强一致性、业务代码侵入小
    - 缺点：性能下降，seata可能本身就不太行
        - Seata支持AT\TCC\Saga三种模式
        - AT：隔离性好，改造成本低，但是性能不行（因为有全局锁）
        - TCC：性能和隔离性好，但是改造成本高
        - Saga：性能好，低改造成本，但是隔离性不行

- 解决方案二：

    * 使用MQ, 生产者确认消息发送成功后，不同的消费者订阅消息消费
        * 同时保证消息处理的幂等性
        * 保证Broker的高可用
        * **保证了最终一致性**。假如说ComsumerA消费成功了，ComsumerB失败了，这个消息就还在这个MQ队列里面。然后就重试消息，如果超过阈值了，推到告警平台（运维人员去查看为什么失败）。
    * 优点
        * 实现简单，改造成本小
        * 性能高，没有全局锁
    * 缺点
        * 弱一致性，需要强一致性的场景不适用
        * 消费者消费失败，需要额外写接口回滚生产者业务逻辑
    * 特点
        * 消息投给mq之后，马上返回给用户结果。这样性能非常高，但是B端还是可能会失败，我们允许这种失败（通过告警排查就好了）。